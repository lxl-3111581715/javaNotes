
数据类型：
    1 数据类型分类
    2 数据类型的判断
    3 数据类型的转换
基本运算符
    1 
程序逻辑
    1 循环
    2 分支
    3 顺序

对象
    
/**
* 基本数据类型：
*  1 string
*  2 number
*  3 boolean
*  4 null
*  5 undefiend
*  
*  6 object
* 对象：
*  1 除基本数据类型之外的数据
*   1 基本数据类型之间没有联系
*   2 基本数据类型创建的变量 都是独立的 没有联系
*   3 对象分类
*          1 内建对象
*              math
*              string
*          2 宿主对象
*              由js运行环境提供的对象
*              目前来讲主要指浏览器提供的对象
*                  BOM DOM
*          3 自建对象
*              由开发人员自己创建的对象
*/



/**
* 对象的基本操作：
*      1 创建对象
*             1 var obj = new Object();
*             2 使用new关键字 创建的对象  调用的函数  是构造函数
*             3 构造函数是专门用来创建对象的函数
*             4 使用typeof检查对象的类型时， 返回的时 object类型
              5 使用工厂方法创建对象

*      2 向对象中添加属性：
*              1 对象.属性名 = value
* 
*      3 读取对象中的属性：
*               1 对象.属性
*               2 读取对象中没有的属性 不会报错  返回 undefined
*      4 修改对象的属性：
*               1 对象.属性名 = value
*      5 删除对象的属性：
*               1 delete 对象.属性名
*  
*/


/**
* 属性名和属性值：
*  1 属性名：
*        1  不强制执行标识符规范
*        2  不能用 点 的方式
*        3  存  对象["属性名"] = 属性值
*        4  取  对象["属性名"]
*        5  中括号中可以传变量
*  2 属性值：
*        1 js对象的属性值可以是任意的数据类型
*        2 in运算符：
*              1 通过该运算符可以检查一个对象中是否含有指定的属性
*              2 如果有返回 ture 没有返回 false
*              3 语法：
*                      "属性名" in 对象
*              4 eg console.log("test" in obj)
*/

/**
* 基本数据类型和引用数据类型
* 1  
* 2 
* 3 基本数据类型和引用数据类型的区别：
*     1 栈内存 变量名  
*     2 堆内存 变量值  
*     3 基本数据类型直接在栈内存中保存 值与值之间是相互独立
*     4 对象保存在堆内存中  栈内存变量名对应的值 保存的是  堆内存中的对象的地址
* eg1:
* var a = "1243"
* b =a
* a = 11111
* console.log(a) // 11111  
* console.log(b) // 1243
* eg2:
* var obj = { name:"123"}
* var obj2 = obj
* obj.name = "11111"
* console.log(obj.name) // 11111
* console.log(obj2.name) // 11111
* 
* 1 当比较基本数据类型是  就是比较值
* 2 当比较对象的时候  要比较内存地址
* 
*/


/**
* 对象字面量：
*  1 使用字面量来创建对象
*  2 var obj = { }
*  3 使用字面量来创建对象 可以在创建 对象的 时候 直接赋值
*  4 属性名和属性值是 键值对
*  5  
*/


/**
* 函数的简介：
*    1 函数也是一个对象
*    2 函数中可以封装一些功能代码 可执行的程序 需要的时候定义
*    3 创建函数对象：
*           1 var fun = new Function()
*    4 封装到函数中的代码不会立即执行
*    5 函数中的代码会在函数调用的时候执行
*    6 当调用函数的时候 函数 中的代码会按照顺序执行
*    7 函数对象具有所有普通对象的功能
*    8 开发中定义函数 很少使用构造函数来定义函数
*    9 使用函数声明创建函数
*             function 函数名(args1,args2,...){
*                       //函数体               
*                  }
*    10 使用函数表达式来创建函数 创建一个匿名函数 然后赋值给变量
*          1   var 函数名 = function(){
*                  
*                  }
*/

/**
* 方法：
* 1 对象的属性值可以是任意类型 也可以是一个函数
* 2 调方法 调函数
* 3 枚举对象中的属性
*          1 使用 for  in  语句
*              for(var 变量 in 对象){
*                      
*              }
* 4 eg
* var obj = {
*       name: 'lixiaol',
*       age: 12,
*       gender: '男'
*   }
*   for (var n in obj) {
*       console.log('Object--------->', n)
*   }
* 5 枚举取出属性名
* 6 枚举去除属性值
* 
*   var obj = {
*       name: 'lixiaol',
*       age: 12,
*       gender: '男'
*  }
*   // 枚举取属性名
*   for (var n in obj) {
*       console.log('Object--------->', n)
*   }
*    // 枚举取属性值
*  for (var n in obj) {
*        console.log('Object--------->', obj[n])
*        
*    }

/**
* 枚举对象中的属性
* 1 
*/

/**
    * 作用域：
    * 1 指的是一个变量的作用范围
    * 2 分类：
    *      1 全局作用域
    *          全局作用域在页面打开的时候创建  页面关闭时销毁
    *          全局作用域中有一个全局对象  wimdow 可以直接使用
    *          代表浏览器窗口
    *          由浏览器创建
    *          在全局作用域中：
    *                  1 创建的对象会作为window的属性保存在window对象中
    *                  2 创建的函数都会作为window的方法保存
    *                  变量的声明提前：
    *                      1 var 关键字 声明的变量 会在所有的代码执行前被声明 变量提升
    *                  函数的声明提前：
    *                      1 使用函数声明的方式创建的函数 会在所有的代码执行之前就被创建
    *                      2 使用函数表达式创建的函数，不会被声明提前 不能在声明前调用 
    *          
    *      2 函数作用域
    *          1 调用函数时 创建函数作用域 函数执行完毕，函数作用域销毁
    *          2 每调用一次函数，就会创建一个全新的函数作用域
    *          3 函数中可以访问到全局作用域中的变量
    *          4 全局作用域中无法访问到函数中定义的变量
    *          5 在函数作用域中  操作一个变量的时候，先在自身中寻找 如果有直接使用 如果没有 向上一级作用域中继续寻找 直到全局作用域没有 报错
    *          6 在函数中直接访问全局作用域中的变量  可以使用 window.
    *          7 在函数作用域中有提前声明的特点
    *          8 在函数中不使用 var 声明的 变量  是全局变量
    */

    /**
     * debug: 
     * 1 js的断点调试
     * 2 
     */

     /**
      * this:
      *     1 解析器在调用函数的时候，每次都会向函数中传递一个隐含的参数
      *     2 隐含的参数叫做 this'
      *     3 this指向的是一个对象
      *     4 函数执行的上下文对象
      *     5 根据函数的 调用的方式 的不同 this会指向不同的对象
      *        1 以函数的方式调用的时候 this 指向的是 window 
      *        2 以方法的形式调用时， this 指向的就是调用方法的那个对象啊
      *     6 this的妙用 让程序更加灵活
      */

/**
 * 使用工厂函数创建对象
 *  1 通过该方法创建新的对象
 *  2  
 */
function createPerson(){
    var obj = new Object();
    return obj
}

/**
 * 构造函数
 * 1 普通函数直接调用 构造函数需要使用 new 关键字调用
 * 2 和普通函数没有区别  首字母大写
 * 3 构造函数的执行流程
 *      1 立刻创建新的对象
 *      2 将新建的对象设置为函数中的this  当对象以构造函数的方式创建的时候 this就是新创建的对象
 *      3 逐行执行函数中的代码
 *      4 将新键 的对象 作为返回值返回
 */

 /**
  * 原型对象：
  *     1 prototype
  *     2 我们创建的每一个函数 解析器都会 向 函数中添加一个 prototype 属性
  *     3 这个属性对应着一个对象  就是原型对象
  *     4 如果函数作为普通函数调用 那么 prototype 属性没有任何作用
  *     5 当函数以构造函数的形式调用的时候 他所创建的对象中 有一个隐含的属性 指向该构造函数的原型对象
  *     6 实例的原型对象： __proto__
  *     7 构造函数的原型对象：prototype 
  *     8 
  */

/**
 * 
 */







函数




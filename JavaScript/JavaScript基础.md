#  JavaScript基础

## 01

```
数据类型：
    1 数据类型分类
    /**
* 基本数据类型：
*  1 string
*  2 number
*  3 boolean
*  4 null
*  5 undefiend
*  
*  6 object
* 对象：
*  1 除基本数据类型之外的数据
*   1 基本数据类型之间没有联系
*   2 基本数据类型创建的变量 都是独立的 没有联系
*   3 对象分类
*          1 内建对象
*              math
*              string
*          2 宿主对象
*              由js运行环境提供的对象
*              目前来讲主要指浏览器提供的对象
*                  BOM DOM
*          3 自建对象
*              由开发人员自己创建的对象
*/

2 数据类型的判断
3 数据类型的转换
```

```
1 数据类型分类:
		1  基本数据类型 
			[值类型]String:Number:Boolean:Undefiend: var b  
			当声明变量但是没有赋值的时候  值就是undefined 表示未定义Null:  
			类型是 object 表示一个为空的对象
		2 引用数据类型 [对象类型]Object:  任意对象  {内部数据无序}     
        	Var  ojb = {}Function:  一种特别的对象{可以执行  内部有可运行的代码}     
        	Function test () {}Array: 一种特别的对象  { 1属性是数字下标属性 2 内部数据是有序的}     
        	Var arr = [ s,’dss’]     Arr[1]  {获取数组数据}      
2 判断数据类型:
		1  typeoftypeof返回值:*  返回数据类型的字符串表达[]*  undefined *  数值*  布尔值
		2  instanceof* 判断对象的具体类型* instancof前的对象  是不是  instanceod 后面构造函数的实例对象
		3  === [数据转换 俩个数据是完全相等] /*  undefined*  null |
3 强制数据类型转换: 将数据的类型强制转换为其他的数据类型
| Var a =123   
1 转换为string --->  
	(1) 方式1:调用被转换数据类型的tostring()方法
		// 调用a 的 tostring 方法 
		   该方法不会影响到原变量  
		   将转换的结果返回Var b  =  a.tostring();
		   注意: null和undefined 没有tostring()方法 调用会报错
	(2) 调用string 函数 并将被转换的参数传入 A  =  String(参数);
		*使用string 函数做强制类型转换 
		实际上就是调用 tostring 方法*对于null 和 undefined 不会调用, 
		会将null/undefiend 直接转换为 ‘null’ / ‘undefiend’ 
2 转转为 numberVar a = ‘123’转换方式:
	(1) 使用number函数A =Number(a),
	(2) 字符串转数值  
		*纯数字的字符串  直接转换 
		*如果字符串中有非数字的内容  则转换为 nan 
		*空字符串  结果是: 0 
3 转换为 booleanTrue:--->1False:-->0 number(boolean值)4 null --> 转数字 --> 05 undefined--> 转数字 ---> nan |
```



## 02

```

基本运算符
    1 
程序逻辑
    1 循环
    2 分支
    3 顺序

对象

/**
* 对象的基本操作：
*      1 创建对象
*             1 var obj = new Object();
*             2 使用new关键字 创建的对象  调用的函数  是构造函数
*             3 构造函数是专门用来创建对象的函数
*             4 使用typeof检查对象的类型时， 返回的时 object类型
              5 使用工厂方法创建对象

*      2 向对象中添加属性：
*              1 对象.属性名 = value
* 
*      3 读取对象中的属性：
*               1 对象.属性
*               2 读取对象中没有的属性 不会报错  返回 undefined
*      4 修改对象的属性：
*               1 对象.属性名 = value
*      5 删除对象的属性：
*               1 delete 对象.属性名
*  
*/


/**
* 属性名和属性值：
*  1 属性名：
*        1  不强制执行标识符规范
*        2  不能用 点 的方式
*        3  存  对象["属性名"] = 属性值
*        4  取  对象["属性名"]
*        5  中括号中可以传变量
*  2 属性值：
*        1 js对象的属性值可以是任意的数据类型
*        2 in运算符：
*              1 通过该运算符可以检查一个对象中是否含有指定的属性
*              2 如果有返回 ture 没有返回 false
*              3 语法：
*                      "属性名" in 对象
*              4 eg console.log("test" in obj)
*/

/**
* 基本数据类型和引用数据类型
* 1  
* 2 
* 3 基本数据类型和引用数据类型的区别：
*     1 栈内存 变量名  
*     2 堆内存 变量值  
*     3 基本数据类型直接在栈内存中保存 值与值之间是相互独立
*     4 对象保存在堆内存中  栈内存变量名对应的值 保存的是  堆内存中的对象的地址
* eg1:
* var a = "1243"
* b =a
* a = 11111
* console.log(a) // 11111  
* console.log(b) // 1243
* eg2:
* var obj = { name:"123"}
* var obj2 = obj
* obj.name = "11111"
* console.log(obj.name) // 11111
* console.log(obj2.name) // 11111
* 
* 1 当比较基本数据类型是  就是比较值
* 2 当比较对象的时候  要比较内存地址
* 
*/


/**
* 对象字面量：
*  1 使用字面量来创建对象
*  2 var obj = { }
*  3 使用字面量来创建对象 可以在创建 对象的 时候 直接赋值
*  4 属性名和属性值是 键值对
*  5  
*/


/**
* 函数的简介：
*    1 函数也是一个对象
*    2 函数中可以封装一些功能代码 可执行的程序 需要的时候定义
*    3 创建函数对象：
*           1 var fun = new Function()
*    4 封装到函数中的代码不会立即执行
*    5 函数中的代码会在函数调用的时候执行
*    6 当调用函数的时候 函数 中的代码会按照顺序执行
*    7 函数对象具有所有普通对象的功能
*    8 开发中定义函数 很少使用构造函数来定义函数
*    9 使用函数声明创建函数
*             function 函数名(args1,args2,...){
*                       //函数体               
*                  }
*    10 使用函数表达式来创建函数 创建一个匿名函数 然后赋值给变量
*          1   var 函数名 = function(){
*                  
*                  }
*/

/**
* 方法：
* 1 对象的属性值可以是任意类型 也可以是一个函数
* 2 调方法 调函数
* 3 枚举对象中的属性
*          1 使用 for  in  语句
*              for(var 变量 in 对象){
*                      
*              }
* 4 eg
* var obj = {
*       name: 'lixiaol',
*       age: 12,
*       gender: '男'
*   }
*   for (var n in obj) {
*       console.log('Object--------->', n)
*   }
* 5 枚举取出属性名
* 6 枚举去除属性值
* 
*   var obj = {
*       name: 'lixiaol',
*       age: 12,
*       gender: '男'
*  }
*   // 枚举取属性名
*   for (var n in obj) {
*       console.log('Object--------->', n)
*   }
*    // 枚举取属性值
*  for (var n in obj) {
*        console.log('Object--------->', obj[n])
*        
*    }

/**
* 枚举对象中的属性
*/

var obj = {
    name: 'lixiaol',
    age: 12,
    gender: '男'
}
// 枚举取属性名
for (var n in obj) {
    console.log('Object--------->', n)
}
// 枚举取属性值
for (var n in obj) {
    console.log('Object--------->', obj[n])
}

console.log(window);

/**
* 作用域：
* 1 指的是一个变量的作用范围
* 2 分类：
*      1 全局作用域
*          全局作用域在页面打开的时候创建  页面关闭时销毁
*          全局作用域中有一个全局对象  wimdow 可以直接使用
*          代表浏览器窗口
*          由浏览器创建
*          在全局作用域中：
*                  1 创建的对象会作为window的属性保存在window对象中
*                  2 创建的函数都会作为window的方法保存
*                  变量的声明提前：
*                      1 var 关键字 声明的变量 会在所有的代码执行前被声明 变量提升
*                  函数的声明提前：
*                      1 使用函数声明的方式创建的函数 会在所有的代码执行之前就被创建
*                      2 使用函数表达式创建的函数，不会被声明提前 不能在声明前调用 
*          
*      2 函数作用域
*          1 调用函数时 创建函数作用域 函数执行完毕，函数作用域销毁
*          2 每调用一次函数，就会创建一个全新的函数作用域
*          3 函数中可以访问到全局作用域中的变量
*          4 全局作用域中无法访问到函数中定义的变量
*          5 在函数作用域中  操作一个变量的时候，先在自身中寻找 如果有直接使用 如果没有 向上一级作用域中继续寻找 直到全局作用域没有 报错
*          6 在函数中直接访问全局作用域中的变量  可以使用 window.
*          7 在函数作用域中有提前声明的特点
*          8 在函数中不使用 var 声明的 变量  是全局变量
*/

/**
* debug: 
* 1 js的断点调试
* 2 
*/

/**
* this:
*     1 解析器在调用函数的时候，每次都会向函数中传递一个隐含的参数
*     2 隐含的参数叫做 this'
*     3 this指向的是一个对象
*     4 函数执行的上下文对象
*     5 根据函数的 调用的方式 的不同 this会指向不同的对象
*        1 以函数的方式调用的时候 this 指向的是 window 
*        2 以方法的形式调用时， this 指向的就是调用方法的那个对象啊
		3 以构造函数的形式调用的时候，this时新创建的对象
		4 使用apply 和 call 调用的时候 this 是指定的对象
*     6 this的妙用 让程序更加灵活
*/

/**
 * 使用工厂函数创建对象
 *  1 通过该方法创建新的对象
 *  2  
 */
function createPerson(){
    var obj = new Object();
    return obj
}

/**
 * 构造函数
 * 1 普通函数直接调用 构造函数需要使用 new 关键字调用
 * 2 和普通函数没有区别  首字母大写
 * 3 构造函数的执行流程
 *      1 立刻创建新的对象
 *      2 将新建的对象设置为函数中的this  当对象以构造函数的方式创建的时候 this就是新创建的对象
 *      3 逐行执行函数中的代码
 *      4 将新建 的对象 作为返回值返回
 */

 /**
  * 原型对象：
  *     1 prototype
  *     2 我们创建的每一个函数 解析器都会 向 函数中添加一个 prototype 属性
  *     3 这个属性对应着一个对象  就是原型对象
  *     4 如果函数作为普通函数调用 那么 prototype 属性没有任何作用
  *     5 当函数以构造函数的形式调用的时候 他所创建的对象中 有一个隐含的属性 指向该构造函数的原型对象
  *     6 实例的原型对象： __proto__
  *     7 构造函数的原型对象：prototype 
  *     8 
  */
  
/**
 * 原型对象：
 * 1 向原型中添加属性
 * 2 
 */

 function MyClass (){

 }
MyClass.prototype.name= "xxx";

 var obj = new MyClass();

 console.log(obj)
 console.log(obj.name)
 obj.hasOwnProtytype  // 只有对象自身含有属性的时候才会返回false


/**
 * toString()
 * 1 对象调用toString()方法
 * 2 直接调用toString()函数
 * 3 当直接打印页面对象  输出的时toString方法的返回值
 * 4 修改当前对象的toString()方法
 * 5 修改原型对象的toString()方法
 */



/**
 * 垃圾回收机制
 * 1 堆内存中的对象地址没有被引用的时候会自动清理
 * 2 垃圾：
 *      1 当一个对象没有任何变量引用  对象地址没有被引用的时候
 * 3 内存溢出
 * 4 在js中 自动的垃圾回收机制 自动将这些 垃圾 回收
 * 5 我们需要做的时将不需要的对象 设置为 null 
 * 
 */

var obj = new Object();
//  对象操作 
obj = null; // 断开地址引用


数组的其他的方法：
/**
 * 数组简介：
 * 1 内建对象
 * 2 array
 * 3 数组也是一个对象
 * 4 也是用来存储数据
 * 5 普通对象使用字符串作为属性名 数组使用 数字下标【索引】来作为属性名
 * 6 索引从零开始
 * 7 数组的存储性能较高
 * 8 
 */

/**
 *  数组操作
 * */

/**
 * 创建对象
 * 1 使用构造函数’
 * 2 使用字面量
 *      1 使用字面量创建数组 在创建的时候就可以赋值
 * 3 
 */
// 通过构造函数
var arr = new Array();
// 通过字面量
var arr2 = [1, 2, 3, 4]

/**
 * 数组操作
 */
// 存
arr[index] = xx;
// 取  读取不存在的索引 返回undefiend
var x = arr[index]

/**
 * 获取数组长度
 * 对于连续的数组  length方法会获取到数组的长度
 * 对于非连续的数组 使用length 会获取到 数组索引最大的长度
 *
 */

var len = arr.length();

/**
 * // 修改length的值
 * // 修改的长度大于原长度  添加空格
 * // 修改的长度小于原长度  多出的元素会被删除
 */

arr.lenth = 10;
var len2 = arr.lenth

/**
 * 通过 length 可以向 数组的 总会向数组最后一位添加 元素
 */

/**
 * 数组中的 元素可以是任意的数据类型
 * 1 基本数据类型 对象 函数
 */

/**
 *数组的四个方法
 * 1 push 向数组的末尾添加一个或者多个元素 并返回数组的长度
 * 2 pop 删除并返回将被删除的元素返回
 * 3 unshift 向数组的开头添加一个元素 并返回数组的长度 向前边添加元素后 后面的元素索引依次调整
 * 4 shift 可以删除数组第一个元素 并将删除的元素作为返回值返回
 */

//  push方法
arr.push("111");


/**
 * 数组的遍历
 * 1 
 */

// for循环
for (var i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

/**
 * for Each  ie8以上
 * 1 一般使用for循环遍历数组
 * 2 for Each 也可以用来遍历数组
 * 3 
 */

//   用法  需要一个函数作为参数
// 由我们创建 不由我们调用 称为回调函数
arr.forEach(function () {
    // 数组中有几个元素就会执行几次
    // 每次执行的时候 浏览器 会将遍历到的 元素 以实参的形式 传递进来
    // 我们可以定义形参 来读取这些内容
    // 浏览器在回调函数中传递三个参数
    // args1: 当前正在便利的元素
    // args2: 当前正在遍历元素的索引
    // args3: 正在遍历的数组
});


/**
 * splice()
 * 1 删除元素中的指定的元素
 * 2 arryObject.aplice(start,end)
 * 3 影响到原数组
 * 4 并将被删除逇元素作为返回值返回
 * 5 参数
 *  1 表示开始位置索引
 *  2 表示删除的数量
 *  3 并向数组添加新元素
 *      1 方法第三，...个参数 自动插入到开始位置索引位置前面
 *      2 
 * 
 */

//  数组去重复练习
var arr3 = [1,4,1,4,3,3,3,2,2,4,5,6,4]




 /**
  * slice()
  * 1 从某个已有的数组中返回选定的元素
  * 2 可以用来从数组中提取指定的元素
  * 3 arryObject.slice(start,end) 包含start 不包含end索引 
  * 4 该方法不会改变原数组
  * 5 而是将截取的作为一个新的数组返回
  * 6 第二个参数可以不写
  * 7 索引可以传递负值
  * 8 
  */


/**
 * 数组的其他的方法：
 * 1 concat()
  * 1 连接俩个或者更多的数组， 并返回结果
  * 2 不会对原数组产生影响
  * 3 
  */
var arr4 = arr.concat(arr3);

/**
 * join()
 * 1 把数组所有的元素放到一个字符串中
 * 2 不会对原数组产生影响
 * 3 在join 方法的参数中 可以指定一个 字符串 作为参数  这个参数将作为数组元素中的连接符
 * 4 如果不指定连接符 则默认使用 ， 作为连接符
 * 5 
 *  */


/**
 * reverse()
 * 1 颠倒数组中元素的位置
 * 2 反转数组
 * 3 会对原数组产生影响
 * 4 
 */


 /**
  * sort()
  * 1 用来对数组进行排序
  * 2 默认按照Unicode编码进行排序
  * 3 自己指定排序的规则
  *     1 在sort中添加一个回调函数 来指定排序规则
  *     2 回调函数中需要定义俩个形参
  *     3 浏览器分别使用数组中的元素作为实参去调用回调函数
  *     4 使用哪一个元素不确定 但是a 在 b  的前面
  *     5 浏览器会根据返回的回调函数的返回值来确定元素的顺序
  *     6 大于0 交换位置 小于 等于0 不交换位置
  * 
  */
//  自定义 sorrt() 方法的排序方法  升序
arr5 = [6,5,2,7,1,4,2,4]
arr5.sort(function(a,b){
  if(a>b){
    return 1
  }else if(a<b){
    return 0
  }esle{
    return onanimationcancel
  }
})


// 升序排列
arr5.sort(function(a,b){
    return a-b;
})
// 降序
arr5.sort(function(a,b){
  return b-a;
})




/**
 * 函数对象的方法：
 * ·1 函数对象的方法  需要通过函数对象来调用
 * ·2 
 */

// ·1 函数对象的方法  需要通过函数对象来调用
function fun(){
  console.log('111111111');
}
// 调用函数方法
fun();
// 调用函数对象的方法
fun.apply();
fun.call();
// 当调用 call apply 方法的时候 都会调用函数执行
// 当使用 call apply 方法的时候 可将对象指定为 第一个参数
// 已函数调用  当前this 是 window
// 此时这个参数对象会成为函数执行时 的 this
// 可以改变 this 的指向

/**
 * 区别：
 * apply()
 * 1 需要将实参封装到数组中统一传递
 * 2 
 * call()
 * 1 可以将实参在对象之后 依次传递
 * 2 
 * 
 * 
 */
 
 
 
 
/**
 * arguments
 * 1 参数列表 实参
 * 2 在调用函数的时候 浏览器 每次会传递俩个隐藏的参数
 *   1 函数的上下文对象  this
 *   2 实参的对象  arguments 
 *     是一个类数组对象
 *     可以通过索引获取数据   
 *     也可以获取数组长度
 *     在调用函数的时候 参数会封装到 arguments中
 *     不定义形参 也可以通过 arguments 来使用实参
 *   3 callee属性
 *      arguments.callee
 *      这个属性对应一个函数对象
 *      就是当前正在执行的函数的对象
 */
 
 

/**
 * Date对象
 * 1 
 * 
 * 
 */
/**
 * 创建对象
 */
var d = new Date();
// 输出当前代码行的日期
console.log(d);
// 创建指定的日期

/**
 * 对象的方法：
 * getDate()  获取当前的日期是几号
 * 
 * getday()  获取当前的日期 
 * 
 */




Math

/**
 * 包装类
 * 1 js为我们提供了三个包装类
 * 2 通过这三个包装类 可以将基本数据类型转换为对象
 * 3 
 */

 var a = 123; // 基本数据类型

 /**
  * String()  可以将基本数据类型 转换为 String对象
  * Number()  可以将基本数据类型 转换为 Number
  * Boolean() 可以将基本数据类型 转换为 Boolean
  */

  /**
   * 通过包装类将基本数据类型转换为对象
   */
  // 创建一个number类型的对象
  var b = new Number(2);
  console.log(b); //3  type object

  /**
   * 转换为对象后 功能更加强大
   * 1 添加属性
   * 2 自动装包
   * 3 自动解包 
   */




/**
 * 字符串的方法
 * 1 字符串的相关方法
 * 2 在底层 以字符数组的形式存在
 * 3
 */

/**
 * str.length()  字符串长度
 */

/**
 *str[index]
 */

/**
*  str.charAt()  :  返回在指定位置【索引】的字符
*/


/**
* str.CharCodeAt() :  返回在指定位置【索引】的字符 的编码
*/


/**
 *  String.formatCharCode():  从字符编码创建一个字符串
 *
 *
*/


/**
 * str.concat() 连接字符串
 *
 */

/**
 * str.indexOf() : 检索一个字符串中是否含有指定的内容
 * 1 如果字符串中含有指定的内容 返回第一次出现内容的索引
 * 2 如果没找到 返回-1值
 * 3 第二个参数可以指定 开始查找的索引
 * 4 第一个参数是要查找的内容
 */

/**
 * str.lastIndexOf()
 * 1 用法和 indexOf() 一样
 * 2 区别是从后往前找
 *
 */


/**
 * str.match()
 */



/**
*str.search()
*/


/**
*str.reprace()
*/



/**
*str.slice()
1 可以截取字符串
2 从字符串中截取指定的内容
3 str.slice(start,end)
4 包括开始  包括结束
5 如果省略第二个参数 直接截取到结尾
*/


/**
*
str.substring(start,end)
1 截取字符串
2 使用和slice方法一样
3 不能接受负值作为参数 传负数默认是0
4 自动5调整参数的位置 第一个位置大于第二个位置的参数  自动交换位置
5
*/


/**
 * str.substr(start,count)
 * 1 用来截取字符串
 * 2 开始
 * 3 截取的数量
 */


/**
 * str.split()
 * 1 将字符串分割为字符串数组
 * 2 将字符串拆分为数组
 * 3 str.split(str1)
 * 4 需要一个字符串作为参数 根据这个字符拆分数组
 */



/**
 * 字符串转大小写方法
 *  str.toLowerCase()
* str.touUppCase()

  * */





 
```



## 03

JavaScript进阶:

| 基础总结:                         |
| --------------------------------- |
| 数据类型:数据,变量,内存对象:函数: |



| Parseint()把一个字符转转换为整数 有效的整数位Parsefloat()  把一个字符串转换为浮点数  非 string类的数据  这俩个方法会先转换为 string 类型 然后再转数字 |
| ------------------------------------------------------------ |
| 其他进制的数字再js中  表示16进制的数字 需要以 0x开头。    表示8进制的数字 ，需要以0开头。    表示二进制的数字。已 0b开头 Praseint中第二个参数可以指定数字的进制 |

 

| 转换为布尔值将其他的数据类型转换为 boolean值Boolean函数0 falseNan： false其他的都是true字符串：除了空串  其余都是trueNull: falseUndefiend: false对象也会转换为 true |
| ------------------------------------------------------------ |
|                                                              |

 

| 运算符：                                                     |
| ------------------------------------------------------------ |
| 通过运算符 可以对一个或者多个值进行操作，并获取运算结果1 运算符都会返回运算结果2 typeof返回类型的  已字符串的方式返回数据类型3 算术运算符+ - * / %+: 数字和数字相加  、  数字和其他类型的数据相加 ， 和 nan 相加  和 null相加和 string类型相加 效果为 拼串,  任何的值和字符做加法 都会转换为字符串，4 一元运算符 5 自增 6 自减 7 逻辑运算符 8 赋值运算符 9 关系运算符 10 unicode编码表 11 相等运算符 12 条件运算符 13 运算符的优先级 |

 

 

 

| Demo                                                         |
| ------------------------------------------------------------ |
| 1 定义基本数据类型Var a Console.log(a, typeof a)   // undefined  ‘undefined’console.log(‘undefiend’ === undefiend)// false Var b = 234 2 定义引用数据类型Var b1 = { B2: [1 , ‘BCc’,console.log], B3: function(){Console.log(‘b3),}}Console.log(b1 instanceof object )// b1是否是 object 构造函数的实例对象  // true* 函数是一种特殊的对象 |

 

| 从不同的数据类型中 取值  赋值判断取出的值是什么类型  使用正确的操作 |
| ------------------------------------------------------------ |
|                                                              |

 

 

| 程序执行顺序：                                               |
| ------------------------------------------------------------ |
| 顺序：分支：条件：                                           |
| ***\*流程控制语句\****：控制程序的执行流程：使程序根据一定的 条件来选择执行语句的分类：* 条件判断语句* 条件分支语句* 循环语句 |
| ***\*条件判断语句：\*******\*If语句（1）：\****执行某个语句之前进行判断  条件成立才会执行语句If ( 条件表达式 ) { // 语句}If语句执行的时候会对条件表达式及进行求值判断 |
| If语句只能控制紧随气其后的那个语句如果希望if语句控制多条语句，可以将语句统一放到代码块中 If语句（2）：如果；；；；；否则；；；If(条件表达式){、、。}else{...} |

 

 

 

| 条件分支语句【2】： switch语句                               |
| ------------------------------------------------------------ |
| // switch语句switch(条件表达式){	case 表达式：		语句。。		break；	case 表达式：		语句	default:		语句。。		break} |
| Switch...case的执行逻辑。1 从满足条件的case开始执行2 如果没有break 则会一直往下执行3 使用case可以保证值执行满足当前条件的case |

Document.write()  想网页中写东西

 

| 循环：35集                                                   |
| ------------------------------------------------------------ |
| While循环：While(条件表达式){ }For 循环：For(){ }            |
| Js进阶                                                       |
| 数据类型复习：1 数据类型分类2 判断数据类型的方法3 undefined和null的区别？4 变量类型  和 数据类型数据类型： 基本类型  对象类型变量类型： 基本类型  引用类型5 数据* 存储在内存中代表特定信息的东西，6 变量:* 7 内存：* 临时的* 内存的产生和死亡:8 内存 变量  数据之间的关系 |
| 实例：实例对象类型：类型对象Function person (name,age) {  // 构造函数 类型This.name = nameThis.age =age}Var p = new person();  // 根据类型创建的实例对象 |
| 对象;* 存储多个数据* 保存多个数据的容器对象的组成：* 方法： 属性值是函数* 属性： 访问对象内部的数据：枚举属性  不可枚举属性*  A. A.[‘’xxx]  通用B. A.Xxx  有时不生效  *属性名包含特殊字符  *变量名不确定 Object 本身的方法Object 的实例方法Object的原型对象  object.prototype()Object的实例Object   当作工具函数使用当作构造函数使用 |
| 函数：1 什么是函数2 如何定义函数*函数声明：【function(){  //...}】*表达式方式：[var fn2 = function(){// ...}]3 如何调用函数* 直接调用* obj.test()  通过对象调用* new test()* test.call/apply(obj)可以让一个函数成为指定的任意对象的方法进行调用 |
| 回调函数：1 回调函数特点* 自定义* 自己没有调用* 最终执行了1 定时器回调函数：* 超时Settimeout(function(){//  },2000)* 循环 2 dom事件回调函数  前台交互Document.getelementbyid(‘btn).onclick = function (){ } 3 ajax请求回调函数  后台交互 4 生命周期回调函数 |
| IIFE 立即调用函数表达式  立即执行函数  匿名函数自调用1 (function(){})()2 隐藏实现3 不会污染外部空间 |
| 函数中的 this1 所有的函数内部都有一个变量this2 他的值是调用函数的当前对象3 任何函数本质上都是通过某个对象来调用的，没有直接指定就是window4 |

 

 

| Webservie                                                    |
| ------------------------------------------------------------ |
| Schema文件：1 约束文档2  schema规范中，所有的标签和属性都需要定义3 所有的schema文件都需要一个id---》namespace4 |
| Namespace  targetnamespace xmlns  schemalocation             |
|                                                              |
|                                                              |

 

 

 

| http协议：                                                   |
| ------------------------------------------------------------ |
|                                                              |
| 请求：请求行：【请求方式】【路径 不包含主机】【协议版本】请求头：【accept:】【accept-lanuage】【user-agent】【host】【connection】keep-active【cookis】维持会话空行：请求体：【只有post请求有】响应：状态行：响应头：响应体：请求的过程： |
|                                                              |
| 一个连接中发一个请求一个连接中发多个请求                     |



 

| Js语句的分号问题; |
| ----------------- |
| js复习：          |
| 对象：1           |
| 函数：1           |
|                   |
|                   |

 

 

 

 

| Js  es6 语法  学习文档：http://caibaojian.com/es6/let.html   |
| ------------------------------------------------------------ |
| 1 结构赋值*打包*解包2 find3 filter4 map5 assign6foreach7 const8 let9 变量提升10 全局作域11 函数作用域12 块级作用域13 严格模式14 |

 

| 正则表达式 |
| ---------- |
|            |

 

 

 

 

 

 

 

 

| 异步数据传输技术 |
| ---------------- |
| 跨域             |
| 隐藏表单域       |
| 标准化的dom      |
| 声明式编程       |
| 转义字符         |
| 关联数组         |
| 弱类型的语言     |
| Dom              |
| Bom              |
| 节点；           |
|                  |
|                  |
|                  |

 